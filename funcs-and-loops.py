# №1 Функция для проверки значений вложенных списков на предмет целого числа (integer) и преобразования к нему, если он не является таковым. На выходе получаем начальный список, но всем целочисленным значениям будет присвоен тип integer.
my_list = [['7', '2', 6 , 7.5, '7.5'],
            ['6', '7', 7, '8.1', '7.2'],
            ['6.5', '18', 1998, '6'],
            ['44', 5, '84', '21']]

def convert_el_to_int(element):
    # проверяем является ли элемент списка строкой
    if isinstance(element, str):
        # если строка проверяем состоит ли элемент только из чисел, если истина, то преобразуем элемент в int
        if element.isdigit():
            return int(element)
        # если возможно преобразовать в вещественный тип, то делаем проверку на целое, если истина, преобразовываем
        # иначе не меняем элемент
        try:
            num = float(element)
            if num.is_integer():
                return int(element)
            return element
        # для ошибок и избежания потери данных возвращаем элемент без изменений
        except ValueError:
            return element
    return element
# используя list comprehension применяем функцию к списку списков.
my_list = [[convert_el_to_int(el) for el in sublist] for sublist in my_list]
print(my_list)

-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

# №2 Проверка существования треугольника

def triangle_check(a, b, c=10):
    """
    Функция проверяет существует ли треугольник с заданными сторонами и возвращает ответ в строковом виде.
    Сторона C задана по умолчанию для наглядности. 
    """
    if all(isinstance(side, int) for side in (a, b, c)):
        if a + b > c and b + c > a and c + a > b:
            print('Треугольник существует')
        else:
            print('Треугольник не существует')
    else:
        print('Все стороны должны быть целыми числами!')

# Примеры вызова функции 

# проверка с параметром по умолчанию
print(triangle_check(10, 21))
# 'Треугольник не существует'

# проверка с тремя заданнами параметрами
print(triangle_check(15, 20, 6))
# 'Треугольник не существует'

# проверка с одной вещественной стороной и параметром по умолчанию
print(triangle_check(7.5, 5))
# 'Все стороны должны быть целыми числами!'
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

# №3 Вывод таблицы умножения на 1-9. Работает только для целых чисел. Без заданного аргумента будет выведена таблица умножения для числа 1.

def num_multiplication_tab(a=1):
    # преобразовываем значение в вещественное и делаем проверку на int
    try:
        a_check = float(a)
        if not a_check.is_integer():
            print('Для дробных я не считаю!')
            return
        # если число прошло проверку, то записываем его в переменную
        # для обработки, если целочисленное число задано в аргумент как строка
        a_int = int(a_check)
    # если будет задан неверный тип, то выводим сообщение об ошибке
    except (ValueError, TypeError):
        print('Ошибка. Введенное значение должны быть целым числом!')
        return
    # при успешном прохождении всех проверок выводим таблицу умножения на экран
    for i in range(1,10):
        print(f'{a} x {i} = {a*i}')

-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

# №4 Поставлена задача из некоторого списка сформировать новый список и вывести для каждого элемента подстроку
# которая начинается с заглавной буквы до конца длины строки.

# Рассмотрим как можно решить данную задачу на примере списка с городами ниже. Применение цикла позволит оставить в списке только названия городов без дополнительной информации.

locality_list = ['Санкт-Петербург', 'посёлок Шушары', 'городской посёлок Янино-1',
       'посёлок Парголово', 'посёлок Мурино', 'Ломоносов', 'Сертолово',
       'Петергоф', 'Пушкин', 'деревня Кудрово', 'Коммунар', 'Колпино',
       'поселок городского типа Красный Бор', 'Гатчина', 'поселок Мурино',
       'деревня Фёдоровское', 'Выборг', 'Кронштадт', 'Кировск',
       'деревня Новое Девяткино', 'посёлок Металлострой',
       'посёлок городского типа Лебяжье',
       'посёлок городского типа Сиверский', 'поселок Молодцово',
       'поселок городского типа Кузьмоловский',
       'садовое товарищество Новая Ропша', 'Павловск',
       'деревня Пикколово', 'Всеволожск', 'Волхов', 'Кингисепп',
       'Приозерск', 'Сестрорецк', 'деревня Куттузи', 'посёлок Аннино',
       'поселок городского типа Ефимовский', 'посёлок Плодовое',
       'деревня Заклинье', 'поселок Торковичи', 'поселок Первомайское',
       'Красное Село', 'посёлок Понтонный', 'Сясьстрой', 'деревня Старая',
       'деревня Лесколово', 'посёлок Новый Свет', 'Сланцы',
       'село Путилово', 'Ивангород', 'Мурино', 'Шлиссельбург',
       'Никольское', 'Зеленогорск', 'Сосновый Бор', 'поселок Новый Свет',
       'деревня Оржицы', 'деревня Кальтино', 'Кудрово',
       'поселок Романовка', 'посёлок Бугры', 'поселок Бугры',
       'поселок городского типа Рощино', 'Кириши', 'Луга', 'Волосово',
       'Отрадное', 'село Павлово', 'поселок Оредеж', 'село Копорье',
       'посёлок городского типа Красный Бор', 'посёлок Молодёжное',
       'Тихвин', 'посёлок Победа', 'деревня Нурма']

# создадим пустой список
city_list = []

# проверяем каждый элемент списка
for city in locality_list:
    # разбиваем каждый элемент списка по символам и ищем первую заглавную букву
    for index, char in enumerate(city):
        if char.isupper():
            # если нашлась заглавная, то добавляем в наш список подстроку с найденного индекса до конца строки
            city_list.append(city[index:])
            break
locality_list = city_list
print(locality_list)

-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

# №5 Пример трех связанных функций для решения аналитической задачи по нахождению ТОП-позиций по продажам и доле и расчету дополнительных показателей. (DataFrame)

import pandas as pd
import numpy as np

def product_agg(df, column_name, sort=True, ascending=False):
    """
    Функция принимает название датафрейма и столбца по которому нужно сгруппировать данные и подсчитать количество записей.
    По умолчанию возвращает результаты по убыванию кол-ва заказов за все время.
    df - аргумент для передачи названия DataFrame.
    column_name - аргумент для передачи названия столбца указанного датафрейма.
    sort - аргумент для активации сортировки. По умолчанию активна.
    ascending - аргумент для настройки типа сортировки. По умолчанию задана сортировка по убыванию.
    Аргументы sort и ascending не рекомендуется менять, если при цепной отработки функций целью выступает нахождения ТОПа.
    """
    return df[column_name].value_counts(sort=sort, ascending=ascending)

def product_partion(top_count, count_col='Количество', partion='Доля, %'):
    """
    Функция дополняет функцию product_agg() и позволяет расчитать долю каждой группе, по которой был сгруппирован результат в функции product_agg()
    top_count - аргумент для передачи результата работы функции product_agg()
    count_col - аргумент для переименования столбца со значениям из функции product_agg()
    partion - аргумент, который задает название столбца в котором будет расчитана доля групп из результата функции product_agg()
    """
    result_df = top_count.rename(count_col).to_frame()
    result_df[partion] = (top_count / top_count.sum() * 100).round(2)
    return result_df

def top_N_product(top_count, category='var_product', price='price', quantity='quantity', time_column='time_order', avg_stats=False, N=5, df=None, days=30):
    """
    Функция выступает аналитическим дополнением к функции product_partion() и позволяет подтянуть ср. цены по группам за указанный период и подсчтиать такие показатели как:
    Объем продаж за N дней, шт., ср. цена за N дней, ср. кол-во в заказе за N дней, Ср. Выручка за N дней. Пустые значения будут заполнены нулями.
    top_count - аргумент для передачи результата работы функции product_partion()
    avg_stats - логический аргумент для расчета показателей указанных в описании функции. По умолчанию не активен. В случае переключения в состояние True
    необходимо проверить наличие обязательных столбцов в переменных в DataFrame: category, price, quantity, time_column
    при не указании или отсутствии в DataFrame значений в аргументах по умолчанию функция вернет список из названий столбцов, которых нет в DataFrame.
    category - аргумент для указания по какому полю группируется исходный DataFrame. Необходимо группировать по аналогичному столбцу в функции product_agg(), т.к.
    мы подтягиваем значения по ранее сгрупированным категория по отработанным функция product_agg() и product_partion() 
    price - аргумент для указания столбца DataFrame, в котором указана цена по товару/группе из столбца в аргументе category
    quantity - аргумент для указания столбца DataFrame, в котором указано кол-во по товару/группе из столбца в аргументе category
    time_column - аргумент для указания столбца DataFrame, в котором находится дата заказа/оформления и т.д.
    N - аргумент для указания сколько строк сверху оставить в результирующем DataFrame. По умолчанию задано значение 5 аналогичано методу .head()
    df - аргумент для указания названия исходного DataFrame из которого будут взяты столбцы из аргументов category, price, quantity, timi_column. Аргумент обязательный, если avg_stats=True. 
    Если аргумент не заполнить, то функция выдаст о ошибку о необходимости прямого указания данного аргумента.
    days - аргумент для указания периода в днях, за который будут расчитаны агрегированные показатели. По умолчанию задано значение 30.
    """
    result_df = top_count.head(N).copy() if isinstance(top_count, pd.DataFrame) else top_count.head(N).to_frame() 
    
    if avg_stats:
        # Выводим ошибку, если было намерение рассчитать ср. значения, но не был указан датафрейм
        if df is None:
            raise ValueError("При avg_stats=True необходимо передать датафрейм в параметр df")
         
        # Проверяем есть ли в указанном датафрейме все необходимые столбцы для расчета
        req_cols = [category, price, quantity, time_column]
        missing = [col for col in req_cols if col not in df.columns]
        if missing:
            raise ValueError(f"В датафрейме {df} отсутствуют обязательные столбцы: {missing}")
        
        # Фильтруем данные за указанный период
        last_date = pd.to_datetime(df[time_column]).max()
        date_filter = last_date - pd.Timedelta(days=days)
        filtered_data = df[pd.to_datetime(df[time_column]) >= date_filter]
        
        # Вытягиваем товары из нашего топа
        products = result_df.index.tolist()
        # Отбираем только товары из полученного списка топ заказываемых позиций и фильтруем
        product_group = filtered_data[filtered_data[category].isin(products)]
        # Группируем для расчета метрик
        groups = product_group.groupby(category)
        
        # Рассчитываем метрики
        result_df[f'Кол-во продаж за {days} дней'] = groups.size()
        result_df[f'Ср. цена за {days} дней'] = groups[price].mean().round(2)    
        result_df[f'Ср. кол-во в заказе за {days} дней'] = groups[quantity].mean().round(2)
        result_df[f'Ср. выручка за {days} дней'] = (result_df[f'Кол-во продаж за {days} дней'] * result_df[f'Ср. цена за {days} дней']).round(2)
        # Заполняем пропуски если за выбранный период заказов не было
        result_df = result_df.fillna(0)
        
        return result_df
    return result_df  

# Пример цепного использования функций для анализа

# Группируем датафрейм по товарам и выводим общее количество заказов по убываюнию
product_count = product_agg(df_proj, 'var_product')
# Используя вторую функцию рассчитываем долю каждого товара/категории
product_count = product_partion(product_count)   
# Используя третью функцию выводим аналитические показатели по топ-3 категориям за последние 30 дней
product_count = top_N_product(product_count, avg_stats=True, N=3, df=df_proj, days=30)
print(product_count)